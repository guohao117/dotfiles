" Plugins {{{1 "
if has('nvim')
    let plugdata = stdpath('data') . '/plugged'
else
    let plugdata = '~/.vim' . '/plugged'
endif
call plug#begin(plugdata)
" retired plugin
" Plug 'majutsushi/tagbar'
" Plug 'bling/vim-airline'
" Plug 'vim-airline/vim-airline-themes'
" Plug 'octol/vim-cpp-enhanced-highlight', { 'for': 'cpp'}

Plug 'altercation/vim-colors-solarized'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'godlygeek/tabular'
Plug 'easymotion/vim-easymotion'
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle'}
Plug 'Xuyuanp/nerdtree-git-plugin', { 'on': 'NERDTreeToggle'}
Plug 'liuchengxu/vista.vim'
Plug 'keith/swift.vim'
Plug 'cespare/vim-toml'
Plug 'rust-lang/rust.vim'
if has('nvim')
    Plug 'neovim/nvim-lspconfig'
endif

Plug 'honza/vim-snippets'
Plug 'SirVer/ultisnips'

if !has('nvim')
    Plug 'roxma/vim-hug-neovim-rpc'
endif
Plug 'ncm2/ncm2'
Plug 'roxma/nvim-yarp'
Plug 'ncm2/ncm2-bufword'
Plug 'ncm2/ncm2-path'
Plug 'ncm2/ncm2-ultisnips'

Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'
Plug 'jremmen/vim-ripgrep'
Plug 'Raimondi/delimitMate'
Plug 'tomtom/tcomment_vim'
Plug 'terryma/vim-multiple-cursors'

" eyecandy stuff
Plug 'itchyny/lightline.vim'

" colorschemes
Plug 'chriskempson/base16-vim'
Plug 'w0ng/vim-hybrid'
Plug 'acarapetis/vim-colors-github'
Plug 'junegunn/seoul256.vim'
Plug 'sonph/onehalf', {'rtp': 'vim'}
Plug 'rakr/vim-one'
" Plug 'joshdick/onedark.vim'

Plug 'airblade/vim-gitgutter'
call plug#end()
" 1}}} "

filetype plugin indent on
" ---------------
" Backups
" ---------------
set backup

" ---------------
" UI
" ---------------
set laststatus=2  " Always show the statusline
set cmdheight=2

" ---------------
" Text Format
" ---------------
set tabstop=4
set softtabstop=4
set shiftwidth=4  " Tabs under smart indent
set cindent
set autoindent
set smarttab
set expandtab
set backspace=2 " Delete everything with backspace

au FileType make setl noexpandtab
augroup c
  au!
  au FileType c setl foldmethod=syntax
  au FileType c setl textwidth=79
  au FileType c setl foldlevel=999
augroup END

augroup cpp
  au!
  au FileType cpp setl foldmethod=syntax
  au FileType cpp setl textwidth=79
  au FileType cpp setl foldlevel=999
augroup END


augroup python
  au!
  au FileType python setl foldmethod=indent
  au FileType python setl foldlevel=999
augroup END

" ---------------
" key mapping
" ---------------
vnoremap <silent> <LocalLeader>= yP
nnoremap <silent> <LocalLeader>= YP

if has('termguicolors') && $COLORTERM ==? "truecolor"
set termguicolors
endif

let g:lightline = {
      \ 'colorscheme': 'one',
      \ }

function! SetColorSchemeDeferred(timer)
    if &bg ==? "dark"
        colorscheme onehalfdark
    else
        colorscheme onehalflight
    endif
endfunction

augroup TUI_Enter
    au!
    autocmd VimEnter * ++nested call timer_start(50, 'SetColorSchemeDeferred', {'repeat': 1})
augroup END

function! UpdateLightLine()
    execute 'source' globpath(&rtp, printf('autoload/lightline/colorscheme/%s.vim', g:lightline['colorscheme']))
    call lightline#colorscheme()
    call lightline#update()
endfunction


augroup UI
    au!
    autocmd OptionSet background call UpdateLightLine()
augroup END

if !empty($TMUX)
    set bg=light
endif

function! SemanticNaviMapping(lsp) abort
    if a:lsp == 'nvim-lsp'
        nnoremap <silent> <Leader>gd    <cmd>lua vim.lsp.buf.declaration()<CR>
        nnoremap <silent> <Leader><c-]> <cmd>lua vim.lsp.buf.definition()<CR>
        nnoremap <silent> <Leader>K     <cmd>lua vim.lsp.buf.hover()<CR>
        nnoremap <silent> <Leader>gD    <cmd>lua vim.lsp.buf.implementation()<CR>
        nnoremap <silent> <Leader><c-k> <cmd>lua vim.lsp.buf.signature_help()<CR>
        nnoremap <silent> <Leader>1gD   <cmd>lua vim.lsp.buf.type_definition()<CR>
        nnoremap <silent> <Leader>gr    <cmd>lua vim.lsp.buf.references()<CR>
        nnoremap <silent> <Leader>g0    <cmd>lua vim.lsp.buf.document_symbol()<CR>
        nnoremap <silent> <Leader>gW    <cmd>lua vim.lsp.buf.workspace_symbol()<CR>
    endif
endfunction

if has('nvim')
lua << EOF
local function config_nvim_lsp(cb_init)
    local nvim_lsp = require'lspconfig'
    local capabilities = vim.lsp.protocol.make_client_capabilities()
    capabilities.textDocument.completion.completionItem.snippetSupport = true
    nvim_lsp.gopls.setup{ init_options = { usePlaceholders = true }; capabilities = capabilities; on_attach = cb_init }
    nvim_lsp.rust_analyzer.setup{ capabilities = capabilities, capabilities = capabilities; on_attach = cb_init }
    nvim_lsp.pyls.setup{ capabilities = capabilities; on_attach = cb_init }
    if vim.call('has', 'mac') == 1 then
        nvim_lsp.clangd.setup{ cmd = {"/usr/local/opt/llvm/bin/clangd", "--background-index"}; capabilities = capabilities; on_attach = cb_init }
    else
        nvim_lsp.clangd.setup{ capabilities = capabilities; on_attach = cb_init }
    end
end

if vim.call('has', 'nvim') == 1 then
    config_nvim_lsp(
        function(client, result)
            local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
            require'ncm2'.register_lsp_source(client, result)
            local opts = { noremap=true, silent=true }
            buf_set_keymap('n', 'gD', '<Cmd>lua vim.lsp.buf.declaration()<CR>', opts)
            buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
            buf_set_keymap('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
            buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
            buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
            buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
            buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
            buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
            buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
            buf_set_keymap('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
            buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
            buf_set_keymap('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
            buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
            buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
            buf_set_keymap('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
            -- Set some keybinds conditional on server capabilities
            if client.resolved_capabilities.document_formatting then
                buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)
            elseif client.resolved_capabilities.document_range_formatting then
                buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.range_formatting()<CR>", opts)
            end
            -- Set autocommands conditional on server_capabilities
            if client.resolved_capabilities.document_highlight then
                vim.api.nvim_exec([[
                hi LspReferenceRead cterm=bold ctermbg=red guibg=LightYellow
                hi LspReferenceText cterm=bold ctermbg=red guibg=LightYellow
                hi LspReferenceWrite cterm=bold ctermbg=red guibg=LightYellow
                augroup lsp_document_highlight
                    autocmd! * <buffer>
                    autocmd CursorHold <buffer> lua vim.lsp.buf.document_highlight()
                    autocmd CursorMoved <buffer> lua vim.lsp.buf.clear_references()
                augroup END
                ]], false)
            end
        end
    )
end
EOF
endif

set completeopt=noinsert,menuone,noselect
autocmd BufEnter * call ncm2#enable_for_buffer()
" We don't really want UltiSnips to map these two, but there's no option for
" that so just make it map them to a <Plug> key.
let g:UltiSnipsExpandTrigger       = "<Plug>(ultisnips_expand_or_jump)"
let g:UltiSnipsJumpForwardTrigger  = "<Plug>(ultisnips_expand_or_jump)"

" Let UltiSnips bind the jump backward trigger as there's nothing special
" about it.
let g:UltiSnipsJumpBackwardTrigger = "<S-Tab>"
let g:UltiSnipsRemoveSelectModeMappings = 0
let g:UltiSnipsEditSplit = 'context'

" Try expanding snippet or jumping with UltiSnips/delimitMate and return <Tab> if nothing
" worked.
function! UniversalJumpForwardOrTab()
  call UltiSnips#JumpForwards()
  if g:ulti_jump_forwards_res > 0
    return ""
  elseif delimitMate#ShouldJump()
    return delimitMate#JumpAny()
  else
    return "\<Tab>"
  endif
endfunction

" what i expected is <CR> only try to expand when popup menu is visible
" otherwise a newline is inserted.
" when popup menu show up, if no item selected, insert <CR>. otherwise insert
" selected item and expand it if possible. I don't want to insert <CR> if the
" slelected item can't be expanded, because <CR> just represent selection not
" a insertion.
inoremap <silent> <expr> <Tab> pumvisible() ? "\<C-n>" : ncm2_ultisnips#expand_or("\<Plug>(ultisnips_try_jump_forwards)")
" i_CTRL-R_= insert expr result
inoremap <silent> <Plug>(ultisnips_try_jump_forwards) <C-R>=UniversalJumpForwardOrTab()<CR>
inoremap <silent> <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
inoremap <silent> <expr> <CR> pumvisible() ? ncm2_ultisnips#expand_or(empty(v:completed_item) ? "<CR>" : "", 'n') : "\<CR>"
" Select mode mapping for jumping forward with <Tab>.
snoremap <silent> <Tab> <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>

let g:vista#renderer#enable_icon = 1

function! VistaLSPorCtags()
  if luaeval('not vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
    echom 'lsp'
    execute 'Vista nvim_lsp'
  else
    echom 'ctags'
    execute 'Vista' 
  endif
endfunction

nnoremap <silent> <expr> <leader>m VistaLSPorCtags()
nnoremap <silent> <C-p> <Esc>:Files<cr>

if has('win32')
    nnoremap <C-z> <Nop>
endif

