" Plugins {{{1 "
if has('nvim')
    let plugdata = stdpath('data') . '/plugged'
else
    let plugdata = '~/.vim' . '/plugged'
endif
call plug#begin(plugdata)
" retired plugin
" Plug 'majutsushi/tagbar'
" Plug 'bling/vim-airline'
" Plug 'vim-airline/vim-airline-themes'
" Plug 'octol/vim-cpp-enhanced-highlight', { 'for': 'cpp'}
" Plug 'norcalli/snippets.nvim'
" Plug 'nvim-lua/completion-nvim'
" Plug 'steelsojka/completion-buffers'

Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'godlygeek/tabular'
Plug 'easymotion/vim-easymotion'
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle'}
Plug 'Xuyuanp/nerdtree-git-plugin', { 'on': 'NERDTreeToggle'}
Plug 'liuchengxu/vista.vim'
Plug 'keith/swift.vim'
Plug 'cespare/vim-toml'
Plug 'rust-lang/rust.vim'
if has('nvim')
    Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
    Plug 'neovim/nvim-lspconfig'
    Plug 'nvim-lua/popup.nvim'
    Plug 'nvim-lua/plenary.nvim'
    Plug 'nvim-telescope/telescope.nvim'
    Plug 'hrsh7th/nvim-compe'
    Plug 'L3MON4D3/LuaSnip'
else
    Plug 'honza/vim-snippets'
    Plug 'SirVer/ultisnips'
    Plug 'ncm2/ncm2'
    Plug 'roxma/vim-hug-neovim-rpc'
    Plug 'roxma/nvim-yarp'
    Plug 'ncm2/float-preview.nvim'
    Plug 'ncm2/ncm2-bufword'
    Plug 'ncm2/ncm2-path'
    Plug 'ncm2/ncm2-ultisnips'
    Plug 'junegunn/fzf'
    Plug 'junegunn/fzf.vim'
endif

Plug 'jremmen/vim-ripgrep'
Plug 'Raimondi/delimitMate'
Plug 'tomtom/tcomment_vim'
Plug 'mg979/vim-visual-multi', {'branch': 'master'}

" eyecandy stuff
Plug 'itchyny/lightline.vim'

" colorschemes
Plug 'chriskempson/base16-vim'
Plug 'altercation/vim-colors-solarized'
Plug 'w0ng/vim-hybrid'
Plug 'acarapetis/vim-colors-github'
Plug 'junegunn/seoul256.vim'
Plug 'sonph/onehalf', {'rtp': 'vim'}
Plug 'rakr/vim-one'
Plug 'guohao117/vim-dracula', { 'as': 'dracula' }
" Plug 'joshdick/onedark.vim'

Plug 'airblade/vim-gitgutter'
Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() }, 'for': ['markdown', 'vim-plug']}
call plug#end()
" 1}}} "

filetype plugin indent on
" ---------------
" Backups
" ---------------
set backup

" ---------------
" UI
" ---------------
set laststatus=2  " Always show the statusline
set cmdheight=2

" ---------------
" Text Format
" ---------------
set tabstop=4
set softtabstop=4
set shiftwidth=4  " Tabs under smart indent
set cindent
set autoindent
set smarttab
set expandtab
set backspace=2 " Delete everything with backspace

au FileType make setl noexpandtab
" augroup c
"   au!
"   au FileType c setl foldmethod=syntax
"   au FileType c setl textwidth=79
"   au FileType c setl foldlevel=999
" augroup END
"
" augroup cpp
"   au!
"   au FileType cpp setl textwidth=79
"   au FileType cpp setl foldlevel=999
" augroup END
"
" augroup python
"   au!
"   au FileType python setl foldmethod=indent
"   au FileType python setl foldlevel=999
" augroup END

augroup go
    au!
    setl noexpandtab
augroup end

if has('termguicolors') && $COLORTERM ==? "truecolor"
set termguicolors
endif

let g:lightline = {
      \ 'colorscheme': 'dracula',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ],
      \             [ 'readonly', 'filename', 'modified', 'method' ] ]
      \ },
      \ 'component_function': {
      \   'method': 'nvim_treesitter#statusline'
      \ },
      \ }

function! SetColorSchemeDeferred(timer)
    " if &bg ==? "dark"
    "     colorscheme onehalfdark
    " else
    "     colorscheme onehalflight
    " endif
    colorscheme dracula
    call UpdateLightline()
endfunction

augroup TUI_Enter
    au!
    autocmd VimEnter * ++nested call timer_start(50, 'SetColorSchemeDeferred', {'repeat': 1})
augroup END

function! UpdateLightline()
    execute 'source' globpath(&rtp, printf('autoload/lightline/colorscheme/%s.vim', g:lightline['colorscheme']))
    call lightline#colorscheme()
    call lightline#update()
endfunction


augroup UI
    au!
    autocmd OptionSet background call UpdateLightline()
augroup END

if !empty($TMUX)
    set bg=dark
endif

function! SemanticNaviMapping(lsp) abort
    if a:lsp == 'nvim-lsp'
        nnoremap <silent> <Leader>gd    <cmd>lua vim.lsp.buf.declaration()<CR>
        nnoremap <silent> <Leader><c-]> <cmd>lua vim.lsp.buf.definition()<CR>
        nnoremap <silent> <Leader>K     <cmd>lua vim.lsp.buf.hover()<CR>
        nnoremap <silent> <Leader>gD    <cmd>lua vim.lsp.buf.implementation()<CR>
        nnoremap <silent> <Leader><c-k> <cmd>lua vim.lsp.buf.signature_help()<CR>
        nnoremap <silent> <Leader>1gD   <cmd>lua vim.lsp.buf.type_definition()<CR>
        nnoremap <silent> <Leader>gr    <cmd>lua vim.lsp.buf.references()<CR>
        nnoremap <silent> <Leader>g0    <cmd>lua vim.lsp.buf.document_symbol()<CR>
        nnoremap <silent> <Leader>gW    <cmd>lua vim.lsp.buf.workspace_symbol()<CR>
    endif
endfunction

if has('nvim')
lua << EOF
local function config_nvim_lsp(cb_init)
    local nvim_lsp = require'lspconfig'
    local capabilities = vim.lsp.protocol.make_client_capabilities()
    capabilities.textDocument.completion.completionItem.snippetSupport = true
	capabilities.textDocument.completion.completionItem.resolveSupport = {
		properties = {
			'documentation',
			'detail',
			'additionalTextEdits',
			}
		}
    nvim_lsp.gopls.setup{ init_options = { usePlaceholders = true }; capabilities = capabilities; on_attach = cb_init }
    nvim_lsp.rust_analyzer.setup{ capabilities = capabilities, capabilities = capabilities; on_attach = cb_init }
    nvim_lsp.jedi_language_server.setup{ capabilities = capabilities; on_attach = cb_init }
    if vim.call('has', 'mac') == 1 then
        nvim_lsp.clangd.setup{ cmd = {"/usr/local/opt/llvm/bin/clangd", "--background-index"}; capabilities = capabilities; on_attach = cb_init }
    else
        nvim_lsp.clangd.setup{ capabilities = capabilities; on_attach = cb_init }
    end
end

if vim.call('has', 'nvim') == 1 then
    config_nvim_lsp(
        function(client, result)
            local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
            -- require'ncm2'.register_lsp_source(client, result)
            local opts = { noremap=true, silent=true }
            buf_set_keymap('n', 'gD', '<Cmd>lua vim.lsp.buf.declaration()<CR>', opts)
            buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
            buf_set_keymap('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
            buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
            buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
            buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
            buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
            buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
            buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
            buf_set_keymap('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
            buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
            buf_set_keymap('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
            buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
            buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
            buf_set_keymap('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
            -- Set some keybinds conditional on server capabilities
            if client.resolved_capabilities.document_formatting then
                buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)
            elseif client.resolved_capabilities.document_range_formatting then
                buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.range_formatting()<CR>", opts)
            end
            -- Set autocommands conditional on server_capabilities
            if client.resolved_capabilities.document_highlight then
                vim.api.nvim_exec([[
                hi LspReferenceRead cterm=bold ctermbg=red guibg=LightYellow
                hi LspReferenceText cterm=bold ctermbg=red guibg=LightYellow
                hi LspReferenceWrite cterm=bold ctermbg=red guibg=LightYellow
                augroup lsp_document_highlight
                    autocmd! * <buffer>
                    autocmd CursorHold <buffer> lua vim.lsp.buf.document_highlight()
                    autocmd CursorMoved <buffer> lua vim.lsp.buf.clear_references()
                augroup END
                ]], false)
            end
        end
    )
    local lang_list = {
        'clojure',
        'rust',
        'toml',
        'jsonc',
        'python',
        'bash',
        'java',
        'json',
        'lua',
        'c_sharp',
        'cpp',
        'go',
        'ruby',
    }
    require'nvim-treesitter.configs'.setup {
      ensure_installed = lang_list, -- one of "all", "maintained" (parsers with maintainers), or a list of languages
      highlight = {
        enable = true,              -- false will disable the whole extension
        disable = { },  -- list of language that will be disabled
      },
      indent = {
        enable = true,
      },
    }
end

EOF
set foldmethod=expr
set foldexpr=nvim_treesitter#foldexpr()
endif

set foldlevel=4

set completeopt=noinsert,menuone,noselect
if has('nvim')
    let g:compe = {}
    let g:compe.enabled = v:true
    let g:compe.autocomplete = v:true
    let g:compe.debug = v:false
    let g:compe.min_length = 1
    let g:compe.preselect = 'enable'
    let g:compe.throttle_time = 80
    let g:compe.source_timeout = 200
    let g:compe.resolve_timeout = 800
    let g:compe.incomplete_delay = 400
    let g:compe.max_abbr_width = 100
    let g:compe.max_kind_width = 100
    let g:compe.max_menu_width = 100
    let g:compe.documentation = v:true

    let g:compe.source = {}
    let g:compe.source.path = v:true
    let g:compe.source.buffer = v:true
    let g:compe.source.calc = v:true
    let g:compe.source.nvim_lsp = v:true
    let g:compe.source.nvim_lua = v:true
    let g:compe.source.vsnip = v:false
    let g:compe.source.ultisnips = v:false
    let g:compe.source.luasnip = v:true
    let g:compe.source.emoji = v:false
else
    autocmd BufEnter * call ncm2#enable_for_buffer()
    " We don't really want UltiSnips to map these two, but there's no option for
    " that so just make it map them to a <Plug> key.
    let g:UltiSnipsExpandTrigger       = "<Plug>(ultisnips_expand_or_jump)"
    let g:UltiSnipsJumpForwardTrigger  = "<Plug>(ultisnips_expand_or_jump)"

    " Let UltiSnips bind the jump backward trigger as there's nothing special
    " about it.
    let g:UltiSnipsJumpBackwardTrigger = "<S-Tab>"
    let g:UltiSnipsRemoveSelectModeMappings = 0
    let g:UltiSnipsEditSplit = 'context'
endif

" Try expanding snippet or jumping with UltiSnips/delimitMate and return <Tab> if nothing
" worked.
function! UniversalJumpForwardOrTab()
    if v:lua.require'luasnip'.expand_or_jump()
        return ""
    elseif delimitMate#ShouldJump()
        return delimitMate#JumpAny()
    else
        return "\<Tab>"
    endif
endfunction

function! MyExpandOr(...)
    if !pumvisible()
        call call('feedkeys', a:000)
        return ""
    endif
    if v:lua.require'luasnip'.expand_or_jump()
        return ""
    else
        call call('feedkeys', a:000)
        return ''
    endif
endfunction

" what i expected is <CR> only try to expand when popup menu is visible
" otherwise a newline is inserted.
" when popup menu show up, if no item selected, insert <CR>. otherwise insert
" selected item and expand it if possible. I don't want to insert <CR> if the
" slelected item can't be expanded, because <CR> just represent selection not
" a insertion.
if has('nvim')
    inoremap <silent> <Plug>(my_jump_forward) <C-r>=UniversalJumpForwardOrTab()<CR>
    inoremap <silent> <expr> <Tab> pumvisible() ? "\<C-n>" : MyExpandOr("\<Plug>(my_jump_forward)")
    inoremap <silent> <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
    " inoremap <silent> <expr> <CR> pumvisible() ? MyExpandOr(empty(v:completed_item) ? "<CR>" : "", 'n') : "\<CR>"
    inoremap <silent><expr> <C-e>     compe#close('<C-e>')
    inoremap <silent><expr> <CR>      compe#confirm('<CR>')
else
    inoremap <silent> <expr> <Tab> pumvisible() ? "\<C-n>" : ncm2_ultisnips#expand_or("\<Plug>(ultisnips_try_jump_forwards)")
    " i_CTRL-R_= insert expr result
    inoremap <silent> <Plug>(ultisnips_try_jump_forwards) <C-r>=UniversalJumpForwardOrTab()<CR>
    inoremap <silent> <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
    inoremap <silent> <expr> <CR> pumvisible() ? ncm2_ultisnips#expand_or(empty(v:completed_item) ? "<CR>" : "", 'n') : "\<CR>"
    " Select mode mapping for jumping forward with <Tab>.
    snoremap <silent> <Tab> <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>
endif

let g:vista#renderer#enable_icon = 0

function! VistaLSPorCtags()
  if luaeval('not vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
    echom 'lsp'
    execute 'Vista nvim_lsp'
  else
    echom 'ctags'
    execute 'Vista' 
  endif
endfunction

nnoremap <silent> <expr> <leader>m VistaLSPorCtags()
" nnoremap <silent> <C-p> <Esc>:Files<cr>
nnoremap <leader>ff <cmd>Telescope find_files<cr>
nnoremap <leader>fg <cmd>Telescope live_grep<cr>
nnoremap <leader>fb <cmd>Telescope buffers<cr>
nnoremap <leader>fh <cmd>Telescope help_tags<cr>

if has('win32')
    nnoremap <C-z> <Nop>
endif
set mouse=a

" gui
autocmd UIEnter * set guifont=PragmataPro\ Liga
